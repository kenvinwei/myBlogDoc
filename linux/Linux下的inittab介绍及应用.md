              
          
    一、什么是initinit是Linux系统操作中不可缺少的程序之一。是一个由内核启动的用户级进程。内核启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等分享微经验，让更多的人受益快去分享吧!!!）之后，就通过启动一个用户级程序init的方式来启动其他用户级的进程或服务。所以,init始终是第一个进程（其PID始终为1）。init的进程号是1（ps -aux |less），从这一点就能看出，init进程是系统所有进程的起点，Linux在完成核内引导以后，就开始运行init程序。init程序需要读取配置文件/etc/inittab。inittab是一个不可执行的文本文件，它有若干行指令所组成。二、运行级别运行级就是操作系统当前正在运行的功能级别。这个级别从1到6，具有不同的功能。其功能级别如下：# 0 - 停机（千万不能把initdefault 设置为0 ）# 1 - 单用户模式# 2 - 多用户，没有 NFS# 3 - 完全多用户模式(标准的运行级)# 4 - 没有用到# 5 - X11 （xwindow)# 6 - 重新启动 （千万不要把initdefault设置为6――把被你黑掉的linux的initdefault设置为0或6也算是拒绝服务攻击噢！）除此之外还有ABC三个运行级别，但在RHLinux中都没有意义。这些级别在/etc/inittab 文件里指定。这个文件是init 程序寻找的主要文件，最先运行的服务是放在/etc/rc.d目录下的文件。在大多数的Linux 发行版本中，启动脚本都是位于 /etc/rc.d/init.d中的。这些脚本被用ln 命令连接到/etc/rc.d/rcn.d 目录。(这里的n 就是运行级0-6)三、运行级别的配置运行级别的配置是在/etc/inittab行内进行的，如下所示：12 : 2 : wait : / etc / init.d / rc 2各字段解释如下：id:runlevels:action:processid：是一个任意指定的四个字符以内的序列标号，在本文件内必须唯一；使用老版本的libc5（低于5.2.18）或a.out库编译出来的sysvinit限制为2字符。注意：像getty之类的登陆进程必须使id字段与tty编号一致，如tty1需要id=1，许多老版本的登陆进程都遵循这种规则。runlevels：表示这一行适用于运行那个/些级别（这里是2，可以有多个，表示在相应的运行级均需要运行）；另外sysinit、boot、bootwait这三个进程会忽略这个设置值。action：表示进入对应的runlevels时，init应该运行process字段的命令的方式，常用的字段值及解释在附录内。例子中的wait表示需要运行这个进程一次并等待其结束。process：具体应该执行的命令。例子中的/etc/init.d/rc命令启动运行级别2中应该运行的进程/命令，并负责在退出运行级时将其终止（当然在进入的runlevel中仍要运行的程序除外。）当运行级别改变，并且正在运行的程序并没有在新的运行级别中指定需要运行，那么init会先发送一个SIGTERM信号终止，然后是SIGKILL。有效的action值如下：respawn：表示init应该监视这个进程，即使其结束后也应该被重新启动。wait：init应该运行这个进程一次，并等待其结束后再进行下一步操作。once：init需要运行这个进程一次。boot：随系统启动运行，所以runlevel值对其无效。bootwait：随系统启动运行，并且init应该等待其结束。off：没有任何意义。initdefault：系统启动后的默认运行级别；由于进入相应的运行级别会激活对应级别的进程，所以对其指定process字段没有任何意义。如果inittab文件内不存在这一条记录，系统启动时在控制台上询问进入的运行级。sysinit：系统启动时准备运行的命令。比如说，这个命令将清除/tmp。可以查看/etc/rc.d/rc.sysinit脚本了解其运行了那些操作。powerwait：允许init在电源被切断时，关闭系统。当然前提是有U P S和监视U PS并通知init电源已被切断的软件。RH linux默认没有列出该选项。powerfail：同powerwait，但init不会等待正在运行的进程结束。RH linux默认没有列出该选项。powerokwait：当电源监视软件报告“电源恢复”时，init要执行的操作。powerfailnow：检测到ups电源即将耗尽时，init要执行的操作，和powerwait/powerfail不同的哟。ctrlaltdel：允许init在用户于控制台键盘上按下C t r l + A l t + De l组合键时，重新启动系统。注意，如果该系统放在一个公共场所，系统管理员可将C t r l + A l t + D el组合键配置为别的行为，比如忽略等。我是设置成打印一句骂人的话了^o^。kbrequest：监视到特定的键盘组合键被按下时采取的动作，现在还不完善。ondemand：A process marked with an ondemandrunlevel will be executed whenever the specified ondemand runlevelis called. However, no runlevel change will occur(ondemand runlevels are ‘a’, ‘b’,and‘c’)，（英语太菜，那个however不知道该怎么翻译才好。惭愧！）补充：1、关于进入单用户模式，一般都是采用设置initdefault为1或者在grub/lilo中指定一个“single”或“emergency”命令行参数来实现。其实另外还有一个更干净的方法，编辑：kernel /vmlinuz-2.6.9-22.EL roroot=/bin/sh，这样init就直接启动一个shell，其他任何进程都没有启动哦，够干净吧！2、系统正在运行时，telinit命令可更改运行级别。运行级别发生变化时， init就会从/etc/inittab运行相应的命令。理解Runlevel：　　runlevel用来表示在init进程结束之后的系统状态，在系统的硬件中没有固定的信息来表示runlevel，它纯粹是一种软件结构。init和inittab是runlevel影响系统状态的唯一原因。在上述例子中inittab文件起始阶段的注释主用来描述runlevel：　　Runlevel 0 是让init关闭所有进程并终止系统。　　Runlevel 1是用来将系统转到单用户模式，单用户模式只能有系统管理员进入，在该模式下处理那些在有登录用户的情况下不能进行更改的文件，改runlevel的编号1也可以用S代替。　　Runlevel 2 是允许系统进入多用户的模式，但并不支持文件共享，这种模式很少应用。　　Runlevel 3 是最常用的运行模式，主要用来提供真正的多用户模式，也是多数服务器的缺省模式。　　Runlevel 4 一般不被系统使用，用户可以设计自己的系统状态并将其应用到runlevel4阶段，尽管很少使用，但使用该系统可以实现一些特定的登录请求。　　Runlevel 5 是将系统初始化为专用的XWindow终端。对功能强大的Linux系统来说，这并不是好的选择，但用户如果需要这样，也可以通过在runlevel启动来实现该方案。　　Runlevel 6 是关闭所有运行的进程并重新启动系统。inittab文件内容：　　###表示当前缺省运行级别为5(initdefault);　　id:5:initdefault:　　###启动时自动执行/etc/rc.d/rc.sysinit脚本(sysinit)　　# System initialization.　　si::sysinit:/etc/rc.d/rc.sysinit　　l0:0:wait:/etc/rc.d/rc 0　　l1:1:wait:/etc/rc.d/rc 1　　l2:2:wait:/etc/rc.d/rc 2　　l3:3:wait:/etc/rc.d/rc 3　　l4:4:wait:/etc/rc.d/rc 4　　###当运行级别为5时，以5为参数运行/etc/rc.d/rc脚本，init将等待其返回(wait)　　l5:5:wait:/etc/rc.d/rc 5　　l6:6:wait:/etc/rc.d/rc 6　　###在启动过程中允许按CTRL-ALT-DELETE重启系统　　# Trap CTRL-ALT-DELETE　　ca::ctrlaltdel:/sbin/shutdown -t3 -r now　　# When our UPS tells us power has failed, assume we have a fewminutes　　# of power left.　Schedule a shutdown for 2 minutes fromnow.　　# This does, of course, assume you have powerd installed andyour　　# UPS connected and working correctly.　　pf::powerfail:/sbin/shutdown -f -h +2 &quot;Power Failure; SystemShutting Down&quot;　　# If power was restored before the shutdown kicked in, cancelit.　　pr:12345:powerokwait:/sbin/shutdown -c &quot;Power Restored;Shutdown Cancelled&quot;　　###在2、3、4、5级别上以ttyX为参数执行/sbin/mingetty程序，打开ttyX终端用于用户登录，　　###如果进程退出则再次运行mingetty程序(respawn)　　# Run gettys in standard runlevels　　1:2345:respawn:/sbin/mingetty tty1　　2:2345:respawn:/sbin/mingetty tty2　　3:2345:respawn:/sbin/mingetty tty3　　4:2345:respawn:/sbin/mingetty tty4　　5:2345:respawn:/sbin/mingetty tty5　　6:2345:respawn:/sbin/mingetty tty6　　###在5级别上运行xdm程序，提供xdm图形方式登录界面，并在退出时重新执行(respawn)　　# Run xdm in runlevel 5　　x:5:respawn:/etc/X11/prefdm -nodaemon　　以上面的inittab文件为例，来说明一下inittab的格式。其中以#开始的行是注释行，除了注释行之外，每一行都有以下格式：　　id:runlevel:action:process　　对上面各项的详细解释如下：　　1. id　　id是指入口标识符，它是一个字符串，对于getty或mingetty等其他login程序项，要求id与tty的编号相同，否则getty程序将不能正常工作。　　2. runlevel　　runlevel是init所处于的运行级别的标识，一般使用0-6以及S或s。0、1、6运行级别被系统保留：其中0作为shutdown动作，1作为重启至单用户模式，6为重启;S和s意义相同，表示单用户模式，且无需inittab文件，因此也不在inittab中出现，实际上，进入单用户模式时，init直接在控制台(/dev/console)上运行/sbin/sulogin。在一般的系统实现中，都使用了2、3、4、5几个级别，在Redhat系统中，2表示无NFS支持的多用户模式，3表示完全多用户模式(也是最常用的级别)，4保留给用户自定义，5表示XDM图形登录方式。7-9级别也是可以使用的，传统的Unix系统没有定义这几个级别。runlevel可以是并列的多个值，以匹配多个运行级别，对大多数action来说，仅当runlevel与当前运行级别匹配成功才会执行。　　3. action　　action是描述其后的process的运行方式的。action可取的值包括：initdefault、sysinit、boot、bootwait等：　　initdefault是一个特殊的action值，用于标识缺省的启动级别;当init由核心激活以后，它将读取inittab中的initdefault项，取得其中的runlevel，并作为当前的运行级别。如果没有inittab文件，或者其中没有initdefault项，init将在控制台上请求输入runlevel。　　sysinit、boot、bootwait等action将在系统启动时无条件运行，而忽略其中的runlevel。　　其余的action(不含initdefault)都与某个runlevel相关。各个action的定义在inittab的man手册中有详细的描述。　　4. process　　process为具体的执行程序。程序后面可以带参数。　　第三部分：系统初始化　　在init的配置文件中有这么一行：　　si::sysinit:/etc/rc.d/rc.sysinit　　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bash shell的脚本，它主要　　在init的配置文件中有这么一行：　　si::sysinit:/etc/rc.d/rc.sysinit　　它调用执行了/etc/rc.d/rc.sysinit，而rc.sysinit是一个bashshell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。　　rc.sysinit约有850多行，但是每个单一的功能还是比较简单，而且带有注释，建议有兴趣的用户可以自行阅读自己机器上的该文件，以了解系统初始化所详细情况。由于此文件较长，所以不在本文中列出来，也不做具体的介绍。　　当rc.sysinit程序执行完毕后，将返回init继续下一步。　　第四部分：启动对应运行级别的守护进程　　在rc.sysinit执行后，将返回init继续其它的动作，通常接下来会执行到/etc/rc.d/rc程序。以运行级别5为例，init将执行配置文件inittab中的以下这行：　　l5:5:wait:/etc/rc.d/rc 5　　这一行表示以5为参数运行/etc/rc.d/rc，/etc/rc.d/rc是一个Shell脚本，它接受5作为参数，去执行/etc/rc.d/rc5.d/目录下的所有的rc启动脚本，/etc/rc.d/rc5.d/目录中的这些启动脚本实际上都是一些链接文件，而不是真正的rc启动脚本，真正的rc启动脚本实际上都是放在/etc/rc.d/init.d/目录下。而这些rc启动脚本有着类似的用法，它们一般能接受start、stop、restart、status等参数。　　/etc/rc.d/rc5.d/中的rc启动脚本通常是K或S开头的链接文件，对于以以S开头的启动脚本，将以start参数来运行。而如果发现存在相应的脚本也存在K打头的链接，而且已经处于运行态了(以/var/lock/subsys/下的文件作为标志)，则将首先以stop为参数停止这些已经启动了的守护进程，然后再重新运行。这样做是为了保证是当init改变运行级别时，所有相关的守护进程都将重启。　　至于在每个运行级中将运行哪些守护进程，用户可以通过chkconfig或setup中的&quot;SystemServices&quot;来自行设定。常见的守护进程有：　　amd：自动安装NFS守护进程　　apmd:高级电源管理守护进程　　arpwatch：记录日志并构建一个在LAN接口上看到的以太网地址和IP地址对数据库　　autofs：自动安装管理进程automount，与NFS相关，依赖于NIS　　crond：Linux下的计划任务的守护进程　　named：DNS服务器　　netfs：安装NFS、Samba和NetWare网络文件系统　　network：激活已配置网络接口的脚本程序　　nfs：打开NFS服务　　portmap：RPC portmap管理器，它管理基于RPC服务的连接　　sendmail：邮件服务器sendmail　　smb：Samba文件共享/打印服务　　syslog：一个让系统引导时起动syslog和klogd系统日志守候进程的脚本　　xfs：X Window字型服务器，为本地和远程X服务器提供字型集　　Xinetd：支持多种网络服务的核心守护进程，可以管理wuftp、sshd、telnet等服务　　这些守护进程也启动完成了，rc程序也就执行完了，然后又将返回init继续下一步。　　第五部分：建立终端　　rc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。init接下来会打开6个终端，以便用户登录系统。通过按Alt+Fn(n对应1-6)可以在这6个终端中切换。在inittab中的以下6行就是定义了6个终端：　　1:2345:respawn:/sbin/mingetty tty1　　2:2345:respawn:/sbin/mingetty tty2　　3:2345:respawn:/sbin/mingetty tty3　　4:2345:respawn:/sbin/mingetty tty4　　5:2345:respawn:/sbin/mingetty tty5　　6:2345:respawn:/sbin/mingetty tty6　　从上面可以看出在2、3、4、5的运行级别中都将以respawn方式运行mingetty程序，mingetty程序能打开终端、设置模式。同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名，而用户输入的用户将作为参数传给login程序来验证用户的身份。　　第六部分：登录系统，启动完成　　对于运行级别为5的图形方式用户来说，他们的登录是通过一个图形化的登录界面。登录成功后可以直接进入KDE、Gnome等窗口管理器。而本文主要讲的还是文本方式登录的情况：　　当我们看到mingetty的登录界面时，我们就可以输入用户名和密码来登录系统了。　　Linux的账号验证程序是login，login会接收mingetty传来的用户名作为用户名参数。然后login会对用户名进行分析：如果用户名不是root，且存在/etc/nologin文件，login将输出nologin文件的内容，然后退出。这通常用来系统维护时防止非root用户登录。只有/etc/securetty中登记了的终端才允许root用户登录，如果不存在这个文件，则root可以在任何终端上登录。/etc/usertty文件用于对用户作出附加访问限制，如果不存在这个文件，则没有其他限制。　　在分析完用户名后，login将搜索/etc/passwd以及/etc/shadow来验证密码以及设置账户的其它信息，比如：主目录是什么、使用何种shell。如果没有指定主目录，将默认为根目录;如果没有指定shell，将默认为/bin/bash。　　login程序成功后，会向对应的终端在输出最近一次登录的信息(在/var/log/lastlog中有记录)，并检查用户是否有新邮件(在/usr/spool/mail/的对应用户名目录下)。然后开始设置各种环境变量：对于bash来说，系统首先寻找/etc/profile脚本文件，并执行它;然后如果用户的主目录中存在.bash_profile文件，就执行它，在这些文件中又可能调用了其它配置文件，所有的配置文件执行后后，各种环境变量也设好了，这时会出现大家熟悉的命令行提示符，到此整个启动过程就结束了。inittab 文档描述在系统引导及通常的操作期间, 都启动哪些进程(比如/etc/init.d/boot,/etc/init.d/rc, getty 等等).Init(8) 讨论有关runlevels (运行级) 的概念, 每一个运行级都有他自己启动进程的集合. 有效的运行级为0 -6加上用于ondemand 条目的A , B 和C . inittab 文档中的每一个条目有如下的格式:id :runlevels :action :process以`#’ 开头的行被忽略.idinittab 文档中条目的唯一标识, 限于1-4 个字符(假如是用版本号小于5.2.18 或a.out的库编译生成的sysvinit 程式, 则仅限于2 个字符).注意: 对于getty 或其他的注册进程, id 必须是响应的终端线路的tty 后缀, 如1 响应tty1 , 否则,注册过程不能正常的工作.runlevels列出发生指定动作的运行级.action描述要发生的动作.process要执行的进程. 假如process 域以一个`+’ 开头, init 不会在utmp 和wtmp 文档中为此进程记帐.这是由于getty 自己主持utmp/wtmp 记帐的需要, 同时这也是个历史遗留的漏洞.runlevels 域能够包含表示不同运行级的多个字符, 例如123 表示本进程在运行级为1, 2 和3 时都要启动.用于ondemand 条目的runlevels 域能够包含A , B , 或C . 用于sysinit , boot ,和bootwait 条目的runlevels 域被忽略.当改变运行级时, 在新运行级中没有给出的那些正在运行的进程被杀死, 先使用SIGTERM 信号, 然后是SIGKILL.action 域能够使用的动作有:respawn该进程只要终止就立即重新启动(如getty).wait只要进入指定的运行级就启动本进程, 并且init 等待该进程的结束.once只要进入指定的运行级就启动一次本进程.boot在系统引导期间执行本进程. runlevels 域被忽略.bootwait在系统引导期间执行本进程. 并且init 等待该进程的结束(如/etc/rc). runlevels 域被忽略.off什么也不做.ondemand在进入ondemand 运行级时才会执行标记为ondemand 的那些进程. 无论怎样, 实际上没有改变运行级(ondemand运行级就是`a’, `b’, 和`c’).initdefaultinitdefault 条目给出系统引导完成后进入的运行级, 假如不存在这样的条目, init 就会在控制台询问要进入的运行级.process 域被忽略.sysinit系统引导期间执行此进程. 本进程会在boot 或bootwait 条目之前得到执行. runlevels 域被忽略.powerwait本进程在电源不足时执行. 通常在有进程把UPS 和电脑相连时通知init 进程, Init在继续其他工作之前要等待此进程结束.powerfail类似powerwait , 但是init 不等待此进程完成.powerokwait在init 收到电源已恢复的通知后立即执行此进程.powerfailnow本进程在init 被告知UPS 电源快耗尽同时外部电源失败(无效) 时被执行. (假设UPS和监控进程能够发现这样的情况).ctrlaltdel在init 收到SIGINT 信号时执行此进程. 这意味着有人在控制台按下了CTRL-ALT-DEL 组合键, 典型地,可能是想执行类似shutdown 然后进入单用户模式或重新引导机器.kbrequest本进程在init 收到一个从控制台键盘产生的特别组合按键信号时执行.对于此功能本文档尚未完成; 能够在kbd-x.xx 包中找到更多信息(在写作本文档时最新的是kbd-0.94).当然您可能想为某些&quot;KeyboardSignal&quot; 行为映射组合键, 如为了映射(Alt-上箭头) 能够在键盘映射文档中使用如下的方式:alt keycode 103 = KeyboardSignal举例这是个和老的Linux inittab 文档类似的例子文档:# inittab for linuxid:1:initdefault:rc::bootwait:/etc/rc1:1:respawn:/etc/getty 9600 tty12:1:respawn:/etc/getty 9600 tty23:1:respawn:/etc/getty 9600 tty34:1:respawn:/etc/getty 9600 tty4本文档在引导时执行/etc/rc 并且在ty1-tty4 上启动getty 进程.一个更详尽的inittab 会有不同的运行级(参考本身的注释):# 进入默认的运行级id:2:initdefault:# 在进行其他工作之前先完成系统初始化.si::sysinit:/etc/rc.d/bcheckrc# 运行级0 挂起系统, 6 重新引导, 1 单用户模式.l0:0:wait:/etc/rc.d/rc.haltl1:1:wait:/etc/rc.d/rc.singlel2:2345:wait:/etc/rc.d/rc.multil6:6:wait:/etc/rc.d/rc.reboot# &quot;3 个键&quot; 按下时要做的工作.ca::ctrlaltdel:/sbin/shutdown -t5 -rf now# 运行级2和3: 在控制台生成getty 进程, 运行级为3时在modem 上生成getty.1:23:respawn:/sbin/getty tty1 VC linux2:23:respawn:/sbin/getty tty2 VC linux3:23:respawn:/sbin/getty tty3 VC linux4:23:respawn:/sbin/getty tty4 VC linuxS2:3:respawn:/sbin/uugetty ttyS2 M19200文档/etc/inittabzylonite 上是::sysinit:/etc/init.d/rcSttyS0::respawn:-/bin/shttyS1::respawn:-/bin/shttyS2::respawn:-/bin/shtty1::respawn:-/bin/shtty2::respawn:-/bin/sh::ctrlaltdel:/bin/umount -a -rfedra 3 上是## inittab This file describes how the INIT process should setup# the system in a certain run-level.## Author: Miquel van Smoorenburg,# Modified for RHS Linux by Marc Ewing and Donnie Barnes## Default runlevel. The runlevels used by RHS are:# 0 - halt (Do NOT set initdefault to this)# 1 - Single user mode# 2 - Multiuser, without NFS (The same as 3, if you do not havenetworking)# 3 - Full multiuser mode# 4 - unused# 5 - X11# 6 - reboot (Do NOT set initdefault to this)#id:3:initdefault:# System initialization.si::sysinit:/etc/rc.d/rc.sysinitl0:0:wait:/etc/rc.d/rc 0l1:1:wait:/etc/rc.d/rc 1l2:2:wait:/etc/rc.d/rc 2l3:3:wait:/etc/rc.d/rc 3l4:4:wait:/etc/rc.d/rc 4l5:5:wait:/etc/rc.d/rc 5l6:6:wait:/etc/rc.d/rc 6# Trap CTRL-ALT-DELETEca::ctrlaltdel:/sbin/shutdown -t3 -r now# When our UPS tells us power has failed, assume we have a fewminutes# of power left. Schedule a shutdown for 2 minutes from now.# This does, of course, assume you have powerd installed andyour# UPS connected and working correctly.pf::powerfail:/sbin/shutdown -f -h +2 &quot;Power Failure; SystemShutting Down&quot;# If power was restored before the shutdown kicked in, cancelit.pr:12345:powerokwait:/sbin/shutdown -c &quot;Power Restored; ShutdownCancelled&quot;# Run gettys in standard runlevels1:2345:respawn:/sbin/mingetty tty12:2345:respawn:/sbin/mingetty tty23:2345:respawn:/sbin/mingetty tty34:2345:respawn:/sbin/mingetty tty45:2345:respawn:/sbin/mingetty tty56:2345:respawn:/sbin/mingetty tty6# Run xdm in runlevel 5x:5:respawn:/etc/X11/prefdm -nodaemon
    
    
      
来自:http://www.i5good.com/20130114154.html