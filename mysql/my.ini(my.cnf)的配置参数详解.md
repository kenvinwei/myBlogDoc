              
          1．获取当前配置参数 要优化配置参数，首先要了解当前的配置参数以及运行情况。使用下列命令可以获得目前服务器使用的配置参数： 1．获取当前配置参数 要优化配置参数，首先要了解当前的配置参数以及运行情况。使用下列命令可以获得目前服务器使用的配置参数： mysqld Cverbose Chelp mysqladmin variables extended-status Cu root Cp 在MySQL控制台里面，运行下列命令可以获取状态变量的值： mysql> SHOW STATUS; 如果只要检查某几个状态变量，可以使用下列命令： mysql> SHOW STATUS LIKE ‘[匹配模式]’; ( 可以使用%、?等 ) 2．优化参数 参数优化基于一个前提，就是在我们的数据库中通常都使用InnoDB表，而不使用MyISAM表。在优化MySQL时，有两个配置参数是最重要的，即table_cache和key_buffer_size。 table_cache table_cache指定表高速缓存的大小。每当MySQL访问一个表时，如果在表缓冲区中还有空间，该表就被打开并放入其中，这样可以更快地访问表内容。通过检查峰值时间的状态值Open_tables和Opened_tables，可以决定是否需要增加table_cache的值。如果你发现open_tables等于table_cache，并且opened_tables在不断增长，那么你就需要增加table_cache的值了（上述状态值可以使用SHOW STATUS LIKE ‘Open%tables’获得）。注意，不能盲目地把table_cache设置成很大的值。如果设置得太高，可能会造成文件描述符不足，从而造成性能不稳定或者连接失败。 对于有1G内存的机器，推荐值是128－256。 案例1：该案例来自一个不是特别繁忙的服务器 table_cache C 512 open_tables C 103 opened_tables C 1273 uptime C 4021421 (measured in seconds) 该案例中table_cache似乎设置得太高了。在峰值时间，打开表的数目比table_cache要少得多。 案例2：该案例来自一台开发服务器。 table_cache C 64 open_tables C 64 opened-tables C 431 uptime C 1662790 (measured in seconds) 虽然open_tables已经等于table_cache，但是相对于服务器运行时间来说，opened_tables的值也非常低。因此，增加table_cache的值应该用处不大。 案例3：该案例来自一个upderperforming的服务器 table_cache C 64 open_tables C 64 opened_tables C 22423 uptime C 19538 该案例中table_cache设置得太低了。虽然运行时间不到6小时，open_tables达到了最大值，opened_tables的值也非常高。这样就需要增加table_cache的值。 key_buffer_size key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。通过检查状态值Key_read_requests和Key_reads，可以知道key_buffer_size设置是否合理。比例key_reads / key_read_requests应该尽可能的低，至少是1:100，1:1000更好（上述状态值可以使用SHOW STATUS LIKE ‘key_read%’获得）。 key_buffer_size只对MyISAM表起作用。即使你不使用MyISAM表，但是内部的临时磁盘表是MyISAM表，也要使用该值。可以使用检查状态值created_tmp_disk_tables得知详情。 对于1G内存的机器，如果不使用MyISAM表，推荐值是16M（8-64M）。 案例1：健康状况 key_buffer_size C 402649088 (384M) key_read_requests C 597579931 key_reads C 56188 案例2：警报状态 key_buffer_size C 16777216 (16M) key_read_requests C 597579931 key_reads C 53832731 案例1中比例低于1:10000，是健康的情况；案例2中比例达到1:11，警报已经拉响。 优化query_cache_size 从4.0.1开始，MySQL提供了查询缓冲机制。使用查询缓冲，MySQL将SELECT语句和查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。根据MySQL用户手册，使用查询缓冲最多可以达到238％的效率。 通过检查状态值Qcache_*，可以知道query_cache_size设置是否合理（上述状态值可以使用SHOW STATUS LIKE ‘Qcache%’获得）。如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况，如果Qcache_hits的值也非常大，则表明查询缓冲使用非常频繁，此时需要增加缓冲大小；如果Qcache_hits的值不大，则表明你的查询重复率很低，这种情况下使用查询缓冲反而会影响效率，那么可以考虑不用查询缓冲。此外，在SELECT语句中加入SQL_NO_CACHE可以明确表示不使用查询缓冲。 与查询缓冲有关的参数还有query_cache_type、query_cache_limit、query_cache_min_res_unit。query_cache_type指定是否使用查询缓冲，可以设置为0、1、2，该变量是SESSION级的变量。query_cache_limit指定单个查询能够使用的缓冲区大小，缺省为1M。query_cache_min_res_unit是在4.1版本以后引入的，它指定分配缓冲区空间的最小单位，缺省为4K。检查状态值Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多，这就表明查询结果都比较小，此时需要减小query_cache_min_res_unit。 开启二进制日志( Binary Log ) 二进制日志包含所有更新数据的语句，其目的是在恢复数据库时用它来把数据尽可能恢复到最后的状态。另外，如果做同步复制( Replication )的话，也需要使用二进制日志传送修改情况。 开启二进制日志，需要设置参数log-bin。log_bin指定日志文件，如果不提供文件名，MySQL将自己产生缺省文件名。MySQL会在文件名后面自动添加数字索引，每次启动服务时，都会重新生成一个新的二进制文件。 此外，使用log-bin-index可以指定索引文件；使用binlog-do-db可以指定记录的数据库；使用binlog-ignore-db可以指定不记录的数据库。注意的是：binlog-do-db和binlog-ignore-db一次只指定一个数据库，指定多个数据库需要多个语句。而且，MySQL会将所有的数据库名称改成小写，在指定数据库时必须全部使用小写名字，否则不会起作用。 在MySQL中使用SHOW MASTER STATUS命令可以查看目前的二进制日志状态。 开启慢查询日志( slow query log ) 慢查询日志对于跟踪有问题的查询非常有用。它记录所有查过long_query_time的查询，如果需要，还可以记录不使用索引的记录。下面是一个慢查询日志的例子： 开启慢查询日志，需要设置参数log_slow_queries、long_query_times、log-queries-not-using-indexes。log_slow_queries指定日志文件，如果不提供文件名，MySQL将自己产生缺省文件名。long_query_times指定慢查询的阈值，缺省是10秒。log-queries-not-using-indexes是4.1.0以后引入的参数，它指示记录不使用索引的查询。 配置InnoDB 相对于MyISAM表来说，正确配置参数对于InnoDB表更加关键。其中，最重要的参数是innodb_data_file_path。它指定表数据和索引存储的空间，可以是一个或者多个文件。最后一个数据文件必须是自动扩充的，也只有最后一个文件允许自动扩充。这样，当空间用完后，自动扩充数据文件就会自动增长（以8MB为单位）以容纳额外的数据。例如： innodb_data_file_path=/disk1/ibdata1:900M;/disk2/ibdata2:50M:autoextend 两个数据文件放在不同的磁盘上。数据首先放在ibdata1中，当达到900M以后，数据就放在ibdata2中。一旦达到50MB，ibdata2将以8MB为单位自动增长。 如果磁盘满了，你需要在另外的磁盘上面增加一个数据文件。为此，你需要查看最后一个文件的尺寸，然后计算最接近的整数（MB）。然后手工修改该文件的大小，并添加新的数据文件。例如：假设ibdata2已经有109MB数据，那么可以修改如下： innodb_data_file_path=/disk1/ibdata1:900M;/disk2/ibdata2:109M;/disk3/ibdata3:500M:autoextend flush_time 如果系统有问题并且经常锁死或重新引导，应将该变量设置为非零值，这将导致服务器按flush_time 秒来刷新表的高速缓存。用这种方法来写出对表的修改将降低性能，但可减少表讹误或数据丢失的机会。 3．存储引擎 在MYSQL 3.23.0版本中，引入了MyISAM存储引擎。它是一个非事务型的存储引擎，成为了MYSQL的缺省存储引擎。但是，如果使用设置向导来设置参数，则它会把InnoDB作为缺省的存储引擎。InnoDB是一个事务型的存储引擎。 创建表的时候，可以为表指定存储引擎，语法如下： CREATE TABLE t (i INT) ENGINE = MyISAM CREATE TABLE t (i INT) TYPE = MyISAM 如果没有指定，则使用缺省的存储引擎。也可以使用ALTER TABLE来更换表引擎，语法如下： ALTER TABLE t ENGINE = MyISAM 同一数据库中可以包含不同存储引擎的表 事务型表具有以下特点： Bulk_insert_buffer_size 该参数于4.0.3中引入。MyISAM使用一个树型的缓冲区来加速大量的插入，如INSERT…SELECT，INSERT…VALUES(…),VALUES(…),…,LOAD DATA INFILE等。该参数指定了缓冲区的大小。缺省值为8M，设置为0则表示不使用该优化。 如果不使用MyISAM表，则可以将其设置为0。 5．InnoDB存储引擎 参考了很多资料，都没有明确地表明如何优化InnoDB参数，以及如何监视这些参数设置是否合理，只有根据MySQL用户手册上面的介绍来进行设置。 innodb_buffer_pool_size 对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样。InnoDB使用该参数指定大小的内存来缓冲数据和索引。对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%。 根据MySQL手册，对于2G内存的机器，推荐值是1G（50%）。 innodb_flush_log_at_trx_commit 该值指定InnoDB记录日志的方式。如果设置为1，则每个事务提交的时候，MySQL都会将事务日志写入磁盘。如果设置为0或者2，则大概每秒中将日志写入磁盘一次。（还不清楚0和2的区别） 实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。 根据MySQL手册，在存在丢失最近部分事务的危险的前提下，可以把该值设为0。 innodb_log_file_size 根据MySQL手册，推荐值是innodb_buffer_pool_size的25%。 注意：在重新设置该值时，好像要把原来的文件删除掉。 innodb_log_buffer_size 根据MySQL手册，推荐值是8M。 innodb_additional_mem_pool_size 该参数指定InnoDB用来存储数据字典和其他内部数据结构的内存池大小。缺省值是1M。通常不用太大，只要够用就行，应该与表结构的复杂度有关系。如果不够用，MySQL会在错误日志中写入一条警告信息。 根据MySQL手册，对于2G内存的机器，推荐值是20M。 SHOW INNODB STATUS 显示InnoDB存储引擎的状态 ==================================================== aborted_clients 客户端非法中断连接次数 aborted_connects 连接mysql失败次数 com_xxx xxx命令执行次数,有很多条 connections 连接mysql的数量 Created_tmp_disk_tables 在磁盘上创建的临时表 Created_tmp_tables 在内存里创建的临时表 Created_tmp_files 临时文件数 Key_read_requests The number of requests to read a key block from the cache Key_reads The number of physical reads of a key block from disk Max_used_connections 同时使用的连接数 Open_tables 开放的表 Open_files 开放的文件 Opened_tables 打开的表 Questions 提交到server的查询数 Sort_merge_passes 如果这个值很大,应该增加my.cnf中的sort_buffer值 Uptime 服务器已经工作的秒数 提升性能的建议: 1.如果opened_tables太大,应该把my.cnf中的table_cache变大 2.如果Key_reads太大,则应该把my.cnf中key_buffer_size变大.可以用Key_reads/Key_read_requests计算出cache失败率 3.如果Handler_read_rnd太大,则你写的SQL语句里很多查询都是要扫描整个表,而没有发挥键的作用 4.如果Threads_created太大,就要增加my.cnf中thread_cache_size的值.可以用Threads_created/Connections计算cache命中率 5.如果Created_tmp_disk_tables太大,就要增加my.cnf中tmp_table_size的值,用基于内存的临时表代替基于磁盘的  Aborted_clients  由于客]有正确关闭连接已经死掉，已经放弃的连接数量。 Aborted_connects  已经失败的的MySQL服务器的连接的次怠 Connections  试图连接MySQL服务器的次怠 Created_tmp_tables  当执行语句时，已经被创造了的隐含临时表的数量。 Delayed_insert_threads  正在使用的延迟插入处理器执行的盗俊 Delayed_writes  用INSERT DELAYED写入的行怠 Delayed_errors  用INSERT DELAYED入的发生某些错误(可能重复键值)的行怠 Flush_commands  执行FLUSH命令的次怠 Handler_delete  请求从一张表中h除行的次数。 Handler_read_first  请求读入表中第一行的次怠 Handler_read_key  请求数字基于键读行。 Handler_read_next  请求读入基于一个键的一行的次怠 Handler_read_rnd  请求读入基于一个固定位置的一行的次数。 Handler_update  请求更新表中一行的次数。 Handler_write  请求向表中插入一行的次数。 Key_blocks_used  用於PI字缓存的K的数量。 Key_read_requests  请求从缓存读入一个键值的次数。 Key_reads  从磁盘物理读入一个键值的次数。 Key_write_requests  请求将一个字段写入缓存次数。 Key_writes  将一个键值物理写入磁盘的次数。 Max_used_connections  同r使用的连接的最大数目。 Not_flushed_key_blocks  在建存中已经改变但是还]被清空到磁盘上的键值。 Not_flushed_delayed_rows  在INSERT DELAY队列中等待写入的行的数量。 Open_tables  打开表的盗俊 Open_files  打开文件的数量。 Open_streams  打开流的数量(主要用于日志记载） Opened_tables  已经打开的表的数量。 Questions  发往服务器的查询的数量。 Slow_queries  要花超过long_query_time时间的查询盗俊 Threads_connected  当前打开的连接的数量。 Threads_running  不在睡眠的执行盗俊 Uptime  服务器工作了多少秒。 关于上面的一些注释： 如果Opened_tables太大，那么你的table_cache数可能太小。 如果key_reads太大，那N你的key_cache可能太小。缓存命中率可以用key_reads/key_read_requests计算。 如果Handler_read_rnd太大，那么你很可能有大量的查询需要MySQL扫描整个表或你有]正确使用键值的连接(join)。     
    
      
来自:http://www.i5good.com/2012011046.html